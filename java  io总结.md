## i/o 模型

- 阻塞式I/O

![img](https://pic1.zhimg.com/80/e83d68da03da2e8c1568b4b4b630edfd_720w.jpg?source=1940ef5c)

- 非阻塞式I/O：进程把一个套接字设置成非阻塞是在通知内核，当所请求的I/O操作非得把本进程投入睡眠才能完成时，不要把进程投入睡眠，而是返回一个错误。

![img](https://pic4.zhimg.com/80/4bc31cab27a9a732ab7d1ba9e674ed64_720w.jpg?source=1940ef5c)

- I/O复用（select，poll，epoll...）：虽然I/O多路复用的函数也是阻塞的，但是其与以上两种还是有不同的，I/O多路复用是阻塞在select，epoll这样的系统调用之上，而没有阻塞在真正的I/O系统调用如recvfrom之上。

![img](https://pic4.zhimg.com/80/b1ec6a4f16844a27c175d5a6a94cd7f8_720w.jpg?source=1940ef5c)

- 信号驱动式I/O（SIGIO）：

- 异步I/O（POSIX的aio_系列函数）：这类函数的工作机制是告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到用户空间）完成后通知我们。

  ![img](https://pic4.zhimg.com/80/5819fd0fdff2bd4fdc9652291aca1831_720w.jpg?source=1940ef5c)



以网络编程中的recv数据过程为例，该过程可以简单理解为将内核空间收到的网络数据拷贝到用户空间。

1. 是**用户进程**负责将内核空间数据拷贝到用户空间，还是**内核进程**负责这个拷贝过程。

- 如果是用户进程负责拷贝，则是同步I/O；
- 如果是内核进程负责拷贝，则是异步I/O；

2. 如果内核空间的数据还没有准备好，那么recv是**等待数据准备好**然后拷贝；还是**立刻返回错误**，告诉用户进程内核数据还没准备好。（拷贝过程实际是由用户进程负责）

- 如果recv一直等待数据准备好，完成拷贝后才返回，则是阻塞I/O；
- 如果内核数据没有准备好，recv立刻返回错误（如EAGAIN错误），则是非阻塞I/O；

**可以看到，无论是阻塞recv还是非阻塞recv，它从内核空间向用户空间拷贝数据的过程其实都是由用户进程负责的，也就是我们的应用程序进程，所以说无论阻塞还是非阻塞，其实都是同步操作。**

非阻塞recv相比非阻塞只是多了一种处理方式：如果数据未准备好，立刻返回错误，而这时候内核空间数据并没有向用户空间进行拷贝。**等到数据准备好，非阻塞recv和阻塞式recv一样，都需要一段时间将数据从内核空间拷贝到用户空间，这个过程用户进程只能负责这一件事，就是拷贝数据**。所以说阻塞、非阻塞I/O 都是同步操作。

**异步I/O则完全不同，因为它其实将这个拷贝过程交给了内核进程去做，用户进程并不参与这个拷贝过程，它只需要等内核进程拷贝完毕给我们发个完成信号或事件就行了。在数据拷贝的这段时间，用户进程可以进行其他工作。**

linux虽然已支持异步I/O，不过当前网络编程中大多还是采用的 select/poll/epoll + send/recv 的 多路I/O复用+同步I/O 模式，异步I/O暂时用的还很少。不过显然异步操作是趋势，也是提高服务器性能的关键。linux下的异步I/O还是需要大型工程项目背书才能扩展开来。

从表面上看：

![这里写图片描述](https://user-gold-cdn.xitu.io/2017/2/23/bf6b2b85deddca81e32d0583513c543e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

**阻塞和非阻塞**描述的是进程的一个操作是否会使得进程转变为“等待”的状态：

- 主动调用 wait() 或 sleep() 等挂起自己的操作
- 调用 System Call, 而 System Call 因为涉及到了 I/O 操作， 不能立即完成， 于是内核就会先将该进程置为等待状态

**非阻塞I/O 系统调用** 和 **异步I/O系统调用 **的区别是：

- 一个非阻塞I/O 系统调用 read() 操作**立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。**
- 而**异步I/O系统调用** read（）**结果必须是完整的**， **但是这个操作完成的通知可以延迟到将来的一个时间点。**
- 在处理 IO 的时候，阻塞和非阻塞都是同步 IO。只有使用了特殊的 API 才是异步 IO。

![img](https://pic2.zhimg.com/50/7d3eb389b7724878bd7e12ebc6dbcdb5_hd.jpg?source=1940ef5c)

## 进程切换

进程切换中几个最重要的步骤：

1. 当一个程序正在执行的过程中， 中断（interrupt） 或 系统调用（system call） 发生可以使得 CPU 的控制权会从当前进程转移到操作系统内核。
2. 操作系统内核负责保存进程 i 在 CPU 中的上下文（程序计数器， 寄存器）到 PCBi （操作系统分配给进程的一个内存块）中。
3. 从 PCBj 取出进程 j 的CPU 上下文， 将 CPU 控制权转移给进程 j ， 开始执行进程 j 的指令。

进程切换通常至少需要花费 300 us 的时间



## 流io ,块io

操作系统与 Java 基于流的 I/O模型有些不匹配。操作系统要移动的是大块数据（缓冲区），这往往是在硬件直接存储器存取（DMA）的协助下完成的。而 JVM 的 I/O 类喜欢操作小块数据——单个字节、几行文本。结果，操作系统送来整缓冲区的数据，java.io 的流数据类再花大量时间把它们拆成小块，往往拷贝一个小块就要往返于几层对象。操作系统喜欢整卡车地运来数据，java.io 类则喜欢一铲子一铲子地加工数据。

Buffer与BufferInputStream的区别：Buffer是缓冲区，BufferInputStream是包装类，NIO缓冲区的底层实现将缓冲区ByteBuffer直接与硬件或者内存连接；而IO是操作系统内存将数据复制到JVM内存中，再在JVM内存上进行操作。

流和通道的区别：从编程角度来讲，流是基于字节的，而通道是基于块的。

- BIO和NIO的区别

(1)bio是面向流的(字节流/字符流),nio是面向buffer的。

(2)bio是阻塞io，nio是非阻塞io。其实本质上nio还是同步的。

nio本质上还是同步io(只不过解耦了)，因为只有等到io事件就绪后，才能执行相应的read/write操作(read和write操作还是要等操作系统内核就绪后由当前线程去执行)。

## 传统读操作

当应用程序执行 read 系统调用读取一块数据的时候，如果这块数据已经存在于用户进程的页内存中，就直接从内存中读取数据；如果数据不存在，则先将数据从磁盘加载数据到内核空间的读缓存（read buffer）中，再从读缓存拷贝到用户进程的页内存中。

```cpp
read(file_fd, tmp_buf, len);
```

基于传统的 I/O 读取方式，read 系统调用会触发 2 次上下文切换，1 次 DMA 拷贝和 1 次 CPU 拷贝，发起数据读取的流程如下：

1. 用户进程通过 read() 函数向内核（kernel）发起系统调用，上下文从用户态（user space）切换为内核态（kernel space）。
2. CPU利用DMA控制器将数据从主存或硬盘拷贝到内核空间（kernel space）的读缓冲区（read buffer）。
3. CPU将读缓冲区（read buffer）中的数据拷贝到用户空间（user space）的用户缓冲区（user buffer）。
4. 上下文从内核态（kernel space）切换回用户态（user space），read 调用执行返回。

## bio, nio



关于何时该采用传统io，何时应该采用nio： 

1) 扩展性考虑：例如在进行Socket编程通信时每一个Socket都应占据一个线程。使用NIO虽然更富有效率，但相对难以编码和扩展。(当然这一现象在不断的被新的设计和NIO库的特性所改善) 

2) 性能考虑：在处理成千上万的连接时，你可能需要更好的传统IO的扩展性；但是如果连接数量较低时，你可能更注重NIO的高吞吐率。 

3) 当使用SSL (Secure Sockets Layer，安全套接字层) 工作时，选择NIO则实现难度很大 

文件通道总是阻塞式的，因此不能被置于非阻塞模式。**现代操作系统都有复杂的缓存和预取机制，使得本地磁盘I/O操作延迟很少**。网络文件系统一般而言延迟会多些，不过却也因该优化而受益。面向流的I/O的非阻塞范例对于面向文件的操作并无多大意义，这是由文件I/O本质上的不同性质造成的。对于文件I/O，最强大之处在于异步I/O（asynchronous I/O），它允许一个进程可以从操作系统请求一个或多个I/O操作而不必等待这些操作的完成。发起请求的进程之后会收到它请求的I/O操作已完成的通知。异步I/O是一种高级性能，当前的很多操作系统都还不具备。以后的NIO增强也会把异步I/O纳入考虑范围。

## bio

BIO中操作的流主要有两大类，字节流和字符流，两类根据流的方向都可以分为输入流和输出流

按照类型和输入输出方向可分为：

1. 输入字节流：InputStream
2. 输出字节流：OutputStream
3. 输入字符流：Reader
4. 输出字符流：Writer

字节流主要用来处理字节或二进制对象，字符流用来处理字符文本或字符串

使用`InputStreamReader`可以将输入字节流转化为输入字符流

```
Reader reader  =  new InputStreamReader(inputStream);
```

使用`OutputStreamWriter`可以将输出字节流转化为输出字符流

```
Writer writer = new OutputStreamWriter(outputStream)
```

![img](https://user-gold-cdn.xitu.io/2019/7/2/16bb0b36e934fc47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![img](https://user-gold-cdn.xitu.io/2019/7/2/16bb0b38f6c20793?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)