### tcp通信图

![1614443816522](C:\Users\wqkant\AppData\Roaming\Typora\typora-user-images\1614443816522.png)

共经历了以下6步。

①TCP是面向字节流传输的协议，它把客户端提交的请求数据看作一连串的无结构的字节流，并不知道所传送的字节流的含义，也并不关心有多少数据流入TCP输出缓冲区中。

②每次发多少数据到网络中与当前的网络拥塞情况和服务端返回的TCP窗口的大小有关，涉及TCP的流量控制和阻塞控制，且与Netty的反压有关。如果客户端发送到TCP输出缓冲区的数据块太多，那么TCP会分割成多次将其传送出去；如果太少，则会等待积累足够多的字节后发送出去。很明显，TCP这种传输机制会产生粘包问题。

③当服务端读取TCP输入缓冲区中的数据时，需要进行拆包处理，并解决粘包和拆包问题，比较常用的方案有以下3种。

将换行符号或特殊标识符号加入数据包中，如HTTP和FTP等。

将消息分为head和body，head中包含body长度的字段，一般前面4个字节是body的长度值，用int类型表示，但也有像Dubbo协议那种，head中除body长度外，还有版本号、请求类型、请求id等。

固定数据包的长度，如固定100个字节，不足补空格。

步骤④～⑥与步骤①～③类似。TCP的这些机制与Netty的编码和解码有很大的关系。Netty采用模板设计模式实现了一套编码和解码架构，高度抽象，底层解决TCP的粘包和拆包问题，对前面介绍的3种方案都做了具体实现。第1种方案，Netty有解码器LineBasedFrameDecoder，可以判断字节中是否出现了“\n”或“\r\n”。第2种方案，Netty有编解码器LengthFieldPrepender和LengthFieldBasedFrameDecoder，可以在消息中加上消息体长度值，这两个编解码器在之前的实战中用到过。